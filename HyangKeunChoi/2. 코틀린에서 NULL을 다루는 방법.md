# 코틀린에서 null을 다루는 방법

1. Kotlin에서의 null 체크
2. Safe Call과 Elvis 연산자
3. 널 아님 단언!!
4. 플랫폼 타입

```java
public boolean startWithA(String str) {
  if(str == null) {
    throw new IllegalArgumentException("A");
  }
  
  return str.startWith("A");
}
```

> nullpointer가 발생할 수 있다.
> 
> 개선한다면...?

```java
public Boolean startsWithA2(String str) {
  if(str == null) {
    return null;
  }
  return str.startsWith("A");
}
```

> 객체 타입이 아니면?

```java
public boolean startsWithA3(String str) {
  if(str == null) {
    return false;
  }
  return str.startsWith("A");
}
```

> 위 세가지 함수를 코틀린에서는???

```kotlin
func startWithA1(str: String?) : Boolean { // null이 들어올수 있으므로  String?
  if(str == null) {
    throw IllegalArgumentException("null")
  }
  return str.startWith("A")
}
```

```kotlin
fun startsWithA2(str: String?): Boolean? {
  if(str == null) {
    return null
  } 
  return str.startWith("A")
}
```

```kotlin
fun startsWithA3(str: String?): Boolean {
  if(str == null_ {
    return false
  }
  return str.startsWith("A")
}
```

2. safe Call과 Elvis 연산자
+ 코틀린에서는 null이 가능한 타입을 완전히 다르게 취급한다.
  - null이 가능한 타입만을 위한 기능은 없나?!

+ Safe Call
```kotlin
var str: String? = "ABC"
str.length // 불가능
str?.length // 가능
```

+ Elvis 연산자
  - 앞의 연산 결과가 null이면 뒤의 값을 실행
```kotlin
val str: String? = "ABC"
str?.length ?: 0
```
  
+ ?: 을 90도 회전하면 elvis와 닮음





